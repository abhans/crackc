# GitHub Actions workflow for CMake C++ project
# This workflow builds, tests, and validates C++ code across multiple platforms

name: CMake Build and Test

# Define when this workflow should run
# Think of these as "triggers" that activate your CI/CD pipeline
on:
  # Trigger on pushes to main branch - catches integration issues early
  push:
    branches: [ "main", "crackc_actions" ]
  
  # Trigger on pull requests targeting main - validates changes before merge
  pull_request:
    branches: [ "main" ]
  
  # Allow manual triggering from GitHub UI - useful for testing workflow changes
  workflow_dispatch:

# Define environment variables that all jobs can access
# These act like global constants for your entire workflow
env:
  # Treat warnings as errors during compilation - enforces code quality
  CMAKE_BUILD_TYPE: Debug
  # Number of parallel jobs for building - speeds up compilation
  CMAKE_BUILD_PARALLEL_LEVEL: 4

# Jobs define the actual work to be done
# Think of each job as a separate virtual machine that runs your tasks
jobs:
  # First job: Build and test across multiple platforms
  build-and-test:
    # Use a matrix strategy to test across different operating systems and compilers
    # This ensures your code works everywhere your users might run it
    strategy:
      fail-fast: false  # Continue testing other combinations even if one fails
      matrix:
        # Define the testing matrix - each combination runs as a separate job
        include:
          # Linux with GCC - most common open-source development environment
          - os: ubuntu-latest
            compiler: gcc
            cpp_compiler: g++
            c_compiler: gcc
          
          # Linux with Clang - alternative compiler with different optimizations
          - os: ubuntu-latest
            compiler: clang
            cpp_compiler: clang++
            c_compiler: clang

    # Specify which virtual machine image to use
    runs-on: ${{ matrix.os }}

    # Define the sequence of steps for this job
    # Each step is like a command you'd run in your terminal
    steps:
    # Step 1: Get your source code
    # This downloads your repository's code to the virtual machine
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # Fetch complete git history - needed for version tagging and git-based tools
        fetch-depth: 0

    # Step 2: Set up the development environment
    # Install compilers and build tools needed for your specific project
    - name: Install dependencies
      if: matrix.os == 'ubuntu-latest'
      run: |
        # Update package manager database
        sudo apt-get update
        
        # Install essential build tools
        sudo apt-get install -y \
          build-essential \
          cmake \
          ninja \
          wget \
          unzip \
          git

        # Install compiler-specific packages
        if [ "${{ matrix.compiler }}" = "clang" ]; then
          sudo apt-get install -y clang llvm
        fi

        # Download and unpack sources
        wget -O opencv.zip https://github.com/opencv/opencv/archive/4.x.zip
        wget -O opencv_contrib.zip https://github.com/opencv/opencv_contrib/archive/4.x.zip
        unzip opencv.zip
        unzip opencv_contrib.zip
        
        # Create build directory
        mkdir -p build && cd build
        
        # Configure
        cmake -DOPENCV_EXTRA_MODULES_PATH=../opencv_contrib-4.x/modules ../opencv-4.x
        
        # Build
        cmake --build .
        
        # Configure OpenCV with contrib modules (includes ArUco)
        cmake -G Ninja \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_INSTALL_PREFIX=/usr/local \
          -DOPENCV_EXTRA_MODULES_PATH=/tmp/opencv_contrib-4.8.1/modules \
          -DBUILD_TESTS=OFF \
          -DBUILD_PERF_TESTS=OFF \
          -DBUILD_EXAMPLES=OFF \
          -DBUILD_DOCS=OFF \
          -DWITH_TBB=ON \
          -DWITH_EIGEN=ON \
          -DOPENCV_ENABLE_NONFREE=ON \
          ..
        
        # Build and install OpenCV (this takes several minutes)
        ninja -j2  # Use only 2 cores to avoid memory issues
        sudo ninja install
        
        # Update library cache
        sudo ldconfig

    # Step 3: Configure the build system
    # This is where CMake analyzes your project and generates build files
    - name: Configure CMake
      run: |
        # Configure CMake exactly like you do locally
        cmake -B build \
          -G Ninja \
          -DCMAKE_BUILD_TYPE=${{ env.CMAKE_BUILD_TYPE }} \
          -DCMAKE_C_COMPILER=${{ matrix.c_compiler }} \
          -DCMAKE_CXX_COMPILER=${{ matrix.cpp_compiler }} \
          -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
          ${{ matrix.os == 'windows-latest' && '-DCMAKE_TOOLCHAIN_FILE=$CMAKE_TOOLCHAIN_FILE' || '' }} \
          .
        
        # Debug: Show what OpenCV version CMake found
        grep -i opencv build/CMakeCache.txt || echo "No OpenCV entries found in CMakeCache.txt"

    # Step 4: Build the project
    # Compile your source code into executable programs
    - name: Build project
      run: |
        # Use CMake to invoke the underlying build system (Ninja in this case)
        cmake --build build --config ${{ env.CMAKE_BUILD_TYPE }} --parallel ${{ env.CMAKE_BUILD_PARALLEL_LEVEL }}

    # Step 5: Test the executables
    # Since your project creates executables rather than libraries with tests,
    # we'll verify that the executables were built successfully
    - name: Verify executables
      working-directory: build
      run: |
        # Check that both executables were created successfully
        if [ "${{ matrix.os }}" = "windows-latest" ]; then
          # Windows executables have .exe extension
          ls -la aruco.exe main.exe
          echo "Both executables built successfully on Windows"
        else
          # Unix-like systems
          ls -la aruco main
          echo "Both executables built successfully on ${{ matrix.os }}"
        fi
        
        # Optionally, you could add basic functionality tests here
        # For example, if your executables support --help or --version flags:
        # ./aruco --help || echo "aruco executable responds"
        # ./main --help || echo "main executable responds"

    # Step 6: Upload build artifacts
    # Save the compiled executables so they can be downloaded from GitHub
    - name: Upload executables
      uses: actions/upload-artifact@v4
      with:
        name: executables-${{ matrix.os }}-${{ matrix.compiler }}
        path: |
          build/aruco${{ matrix.os == 'windows-latest' && '.exe' || '' }}
          build/main${{ matrix.os == 'windows-latest' && '.exe' || '' }}
        retention-days: 30